<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>My Solo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://selfsolo.com/"/>
  <updated>2021-01-07T13:39:40.330Z</updated>
  <id>https://selfsolo.com/</id>
  
  <author>
    <name>Sera Wang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Go】net/url包一定条件下参数获取异常</title>
    <link href="https://selfsolo.com/2021/01/07/%E3%80%90Go%E3%80%91net-url%E5%8C%85%E4%B8%80%E5%AE%9A%E6%9D%A1%E4%BB%B6%E4%B8%8B%E5%8F%82%E6%95%B0%E8%8E%B7%E5%8F%96%E5%BC%82%E5%B8%B8/"/>
    <id>https://selfsolo.com/2021/01/07/【Go】net-url包一定条件下参数获取异常/</id>
    <published>2021-01-07T13:06:32.000Z</published>
    <updated>2021-01-07T13:39:40.330Z</updated>
    
    <content type="html"><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>起因是一次API的测试，发现gin框架在一定条件下解析URL中的查询字符串时，存在获取不到参数的情况。比如输入 index?user=123.%sera，使用gin的 c.Query(“xxx”) 值会返回空。</p><a id="more"></a><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">data := c.DefaultQuery(<span class="string">"x"</span>, <span class="string">""</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(data) == <span class="number">0</span> &#123;</span><br><span class="line">Response(c, <span class="string">"param empty: x"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">f, err := XX.Callback(data)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">Response(c, err.Error())</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">Response(c, f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>GET请求试了几个参数</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP GET: http://127.0.0.1:1234/x?x=y</span><br><span class="line"></span><br><span class="line"><span class="attribute">y:</span></span><br><span class="line"><span class="attribute">test</span></span><br><span class="line"><span class="attribute">test.user</span></span><br><span class="line"> [空格]</span><br><span class="line"><span class="attribute">123.*foo</span></span><br><span class="line"><span class="attribute">123.%foo</span></span><br></pre></td></tr></table></figure><p>前几个参数的返回结果都符合预期，哪怕是空格，gin也都识别了出来，但是到 123.%foo 这个参数时，就发现gin获取不到了，len(x) 为0，以防万一先测试了一下 len(“123.%foo”)是正常的。</p><p>所以推测是gin在URL解析时对查询字符串里的 %参数处理有问题，那么具体是什么原因导致的这个问题呢？</p><h3 id="gin是怎么解析查询字符串的？"><a href="#gin是怎么解析查询字符串的？" class="headerlink" title="gin是怎么解析查询字符串的？"></a>gin是怎么解析查询字符串的？</h3><p>gin实际上使用的是 Golang原生包 net/url提供的 parseQuery()方法，代码如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseQuery</span><span class="params">(m Values, query <span class="keyword">string</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> query != <span class="string">""</span> &#123;</span><br><span class="line">      key := query</span><br><span class="line">      <span class="keyword">if</span> i := strings.IndexAny(key, <span class="string">"&amp;;"</span>); i &gt;= <span class="number">0</span> &#123;</span><br><span class="line">         key, query = key[:i], key[i+<span class="number">1</span>:]</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         query = <span class="string">""</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> key == <span class="string">""</span> &#123;</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      value := <span class="string">""</span></span><br><span class="line">      <span class="keyword">if</span> i := strings.Index(key, <span class="string">"="</span>); i &gt;= <span class="number">0</span> &#123;</span><br><span class="line">         key, value = key[:i], key[i+<span class="number">1</span>:]</span><br><span class="line">      &#125;</span><br><span class="line">      key, err1 := QueryUnescape(key)</span><br><span class="line">      <span class="keyword">if</span> err1 != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">            err = err1</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      value, err1 = QueryUnescape(value)</span><br><span class="line">      <span class="keyword">if</span> err1 != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">            err = err1</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      m[key] = <span class="built_in">append</span>(m[key], value)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本上，它做的就是把 param1=value1&amp;param2=value2，变成如下的一个map，我们调用Query就是获取map中对应key的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"param1"</span>: []<span class="keyword">string</span>&#123;<span class="string">"value1"</span>&#125;,</span><br><span class="line"><span class="string">"param2"</span>: []<span class="keyword">string</span>&#123;<span class="string">"value2"</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但众所周知有URL编码的存在，所以URL包也会URL编码做了处理（它会使用unescape方法对map中的key和value分别做一次URL解码）</p><h4 id="unescape-函数-略长"><a href="#unescape-函数-略长" class="headerlink" title="unescape 函数 (略长)"></a>unescape 函数 (略长)</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unescape unescapes a string; the mode specifies</span></span><br><span class="line"><span class="comment">// which section of the URL string is being unescaped.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unescape</span><span class="params">(s <span class="keyword">string</span>, mode encoding)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">   <span class="comment">// Count %, check that they're well-formed.</span></span><br><span class="line">   n := <span class="number">0</span></span><br><span class="line">   hasPlus := <span class="literal">false</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); &#123;</span><br><span class="line">      <span class="keyword">switch</span> s[i] &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'%'</span>:</span><br><span class="line">         n++</span><br><span class="line">         <span class="keyword">if</span> i+<span class="number">2</span> &gt;= <span class="built_in">len</span>(s) || !ishex(s[i+<span class="number">1</span>]) || !ishex(s[i+<span class="number">2</span>]) &#123;</span><br><span class="line">            s = s[i:]</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(s) &gt; <span class="number">3</span> &#123;</span><br><span class="line">               s = s[:<span class="number">3</span>]</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>, EscapeError(s)</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// Per https://tools.ietf.org/html/rfc3986#page-21</span></span><br><span class="line">         <span class="comment">// in the host component %-encoding can only be used</span></span><br><span class="line">         <span class="comment">// for non-ASCII bytes.</span></span><br><span class="line">         <span class="comment">// But https://tools.ietf.org/html/rfc6874#section-2</span></span><br><span class="line">         <span class="comment">// introduces %25 being allowed to escape a percent sign</span></span><br><span class="line">         <span class="comment">// in IPv6 scoped-address literals. Yay.</span></span><br><span class="line">         <span class="keyword">if</span> mode == encodeHost &amp;&amp; unhex(s[i+<span class="number">1</span>]) &lt; <span class="number">8</span> &amp;&amp; s[i:i+<span class="number">3</span>] != <span class="string">"%25"</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>, EscapeError(s[i : i+<span class="number">3</span>])</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> mode == encodeZone &#123;</span><br><span class="line">            <span class="comment">// RFC 6874 says basically "anything goes" for zone identifiers</span></span><br><span class="line">            <span class="comment">// and that even non-ASCII can be redundantly escaped,</span></span><br><span class="line">            <span class="comment">// but it seems prudent to restrict %-escaped bytes here to those</span></span><br><span class="line">            <span class="comment">// that are valid host name bytes in their unescaped form.</span></span><br><span class="line">            <span class="comment">// That is, you can use escaping in the zone identifier but not</span></span><br><span class="line">            <span class="comment">// to introduce bytes you couldn't just write directly.</span></span><br><span class="line">            <span class="comment">// But Windows puts spaces here! Yay.</span></span><br><span class="line">            v := unhex(s[i+<span class="number">1</span>])&lt;&lt;<span class="number">4</span> | unhex(s[i+<span class="number">2</span>])</span><br><span class="line">            <span class="keyword">if</span> s[i:i+<span class="number">3</span>] != <span class="string">"%25"</span> &amp;&amp; v != <span class="string">' '</span> &amp;&amp; shouldEscape(v, encodeHost) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="string">""</span>, EscapeError(s[i : i+<span class="number">3</span>])</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         i += <span class="number">3</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">         hasPlus = mode == encodeQueryComponent</span><br><span class="line">         i++</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         <span class="keyword">if</span> (mode == encodeHost || mode == encodeZone) &amp;&amp; s[i] &lt; <span class="number">0x80</span> &amp;&amp; shouldEscape(s[i], mode) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>, InvalidHostError(s[i : i+<span class="number">1</span>])</span><br><span class="line">         &#125;</span><br><span class="line">         i++</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> n == <span class="number">0</span> &amp;&amp; !hasPlus &#123;</span><br><span class="line">      <span class="keyword">return</span> s, <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> t strings.Builder</span><br><span class="line">   t.Grow(<span class="built_in">len</span>(s) - <span class="number">2</span>*n)</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">      <span class="keyword">switch</span> s[i] &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'%'</span>:</span><br><span class="line">         t.WriteByte(unhex(s[i+<span class="number">1</span>])&lt;&lt;<span class="number">4</span> | unhex(s[i+<span class="number">2</span>]))</span><br><span class="line">         i += <span class="number">2</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">         <span class="keyword">if</span> mode == encodeQueryComponent &#123;</span><br><span class="line">            t.WriteByte(<span class="string">' '</span>)</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            t.WriteByte(<span class="string">'+'</span>)</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         t.WriteByte(s[i])</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> t.String(), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致看了逻辑后就知道问题出在 line 9-17里它对 %号的解析，如果说一个查询字符串使用了不标准的URL编码（一个标准的URL编码由百分号%和字符的ASCII码对应的两位十六进制数组成，比如 %3C。ASCII码范围为 00-7F），那么URL解析就会返回空值和一个解码错误，而Golang对于此错误没有进行处理，所以导致诸如 123.%foo这种值会返回空。</p><h3 id="和Mysql的冲突"><a href="#和Mysql的冲突" class="headerlink" title="和Mysql的冲突"></a>和Mysql的冲突</h3><p>另一个地方，对于 %99 这样无法解码但符合 Golang的URL包中描述的 %[0-9a-fA-F]{2} 逻辑的，又会报一个新的错误：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error <span class="number">1267</span>: Illegal mix of collations (utf8_general_ci,IMPLICIT) and (utf8mb4_general_ci,COERCIBLE) <span class="keyword">for</span> operation <span class="string">'='</span></span><br></pre></td></tr></table></figure><p>这个错误是Mysql抛出来的，原因是因为Golang的URL包对一个URL编码的判断标准是 %[0-9a-fA-F]{2}，符合此标准它就不会抛出解码错误，但是它却会尝试对其进行解码，解码的函数如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unhex(s[i+<span class="number">1</span>])&lt;&lt;<span class="number">4</span> | unhex(s[i+<span class="number">2</span>])</span><br></pre></td></tr></table></figure><p>即它会将 %99解码成一个ASCII码，但显然不在ASCII码里就会和Mysql的编码冲突，于是Mysql就把这个错误给抛了出来。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h3&gt;&lt;p&gt;起因是一次API的测试，发现gin框架在一定条件下解析URL中的查询字符串时，存在获取不到参数的情况。比如输入 index?user=123.%sera，使用gin的 c.Query(“xxx”) 值会返回空。&lt;/p&gt;
    
    </summary>
    
    
      <category term="开发" scheme="https://selfsolo.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Golang" scheme="https://selfsolo.com/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>机器学习 - 入门篇</title>
    <link href="https://selfsolo.com/2020/05/30/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%85%A5%E9%97%A8%E7%AF%87/"/>
    <id>https://selfsolo.com/2020/05/30/机器学习-入门篇/</id>
    <published>2020-05-30T03:04:06.000Z</published>
    <updated>2020-05-30T13:44:14.673Z</updated>
    
    <content type="html"><![CDATA[<p>大一的时候，想到Lab里玩耍，有个博导就跟我聊天，过程中他讲到”么瑟乐宁”，我边听边确认多遍，才知道，噢，是”MachineLearning”。一晃二三年，经过这些年的耳濡目染和博士师兄的安利，对于这个词真是不能再熟悉了。而直到前段时间在工作中看到同事使用HMM对某传统安全产品进行了一次成功的优化时，内心才坚定了”MachineLearning是新英雄时代的阿尔戈”这一想法，于是再也按捺不住心里那股汹涌澎湃的感觉，春宵苦短，所以开始吧。本篇用于记录学习MachineLearning的笔记和想法。（封面应景 — 《Detroit: Become Human》）</p><p><img src="https://ser4wang.oss-cn-beijing.aliyuncs.com/20200530121422.png" alt></p><a id="more"></a><h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1><h2 id="课程"><a href="#课程" class="headerlink" title="课程"></a>课程</h2><p>Machine Learning - Andrew Ng <a href="https://www.coursera.org/learn/machine-learning/home/welcome" target="_blank" rel="noopener">课程地址</a></p><h2 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h2><p>《Python机器学习》— Sebastian Raschka</p><h2 id="师兄当年安利"><a href="#师兄当年安利" class="headerlink" title="师兄当年安利"></a>师兄当年安利</h2><p>《数学之美》— 吴军</p><p>一些振奋人心的话和介绍</p><blockquote><p>无需多言，大家都已知道，机器学习已发展成为当前最能激发人们兴趣的技术之一。出于各种考虑，Google、Facebook、Apple、Amazon、IBM等众多公司都投入了巨资用于机器学习理论和应用的研究。机器学习看起来已经成为当前的一个流行语，但这绝对不是炒作。这一令人兴奋的技术为我们带来了全新的可能，并已成为我们日常生活中不可或缺的一部分。例如，与智能手机的语音助手对话、向客户推荐合适的商品、防止信用卡诈骗、过滤垃圾邮件，以及检测与诊断疾病等，这样的例子不胜枚举。—— Sebastian Raschka</p></blockquote><h1 id="Python机器学习"><a href="#Python机器学习" class="headerlink" title="Python机器学习"></a>Python机器学习</h1><h2 id="第一章-机器学习"><a href="#第一章-机器学习" class="headerlink" title="第一章 机器学习"></a>第一章 机器学习</h2><h3 id="机器学习的概念"><a href="#机器学习的概念" class="headerlink" title="机器学习的概念"></a>机器学习的概念</h3><p>当前的时代拥有大量的结构化和非结构化的数据，20世纪下半叶，机器学习逐渐演化为人工智能的一个分支，其目的是通过对<strong>自学习算法</strong>的开发，从数据中获取知识，进而对<strong>未来</strong>进行预测。与传统的通过大量数据分析然后人工推导规则（如WAF规则）并构造模型不同，机器学习提供了一种<strong>从数据中获取知识的方法，同时能够逐步提高预测模型的性能，并将模型应用于基于数据驱动的决策中去</strong>。</p><h3 id="机器学习的三种方法"><a href="#机器学习的三种方法" class="headerlink" title="机器学习的三种方法"></a>机器学习的三种方法</h3><h4 id="监督学习-Supervised-Learning"><a href="#监督学习-Supervised-Learning" class="headerlink" title="监督学习 - Supervised Learning"></a>监督学习 - Supervised Learning</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>监督学习的目的是使用有类标的<strong>训练数据</strong>构建模型，我们可以使用经训练得到的<strong>模型</strong>对未来数据进行<strong>预测</strong>。</p><p><strong>监督</strong>是指训练数据集中的每个样本均有一个已知的输出项。</p><blockquote><p>示例：过滤垃圾邮件</p></blockquote><p>基于<strong>有类标</strong>的电子邮件样本库（每一个样本都已被准确地标记是否为垃圾邮件），可以使用监督学习算法训练生成一个判定模型，用来<strong>判定一封新的电子邮件是否为垃圾邮件</strong>。</p><p><img src="https://ser4wang.oss-cn-beijing.aliyuncs.com/20200530120406.png" alt="监督学习示例"></p><p>类似过滤垃圾邮件的这类问题也被称为<strong>分类</strong>（classfication），监督学习的另一个子类是<strong>回归</strong>（regression）。</p><h5 id="利用分类对类标进行预测"><a href="#利用分类对类标进行预测" class="headerlink" title="利用分类对类标进行预测"></a>利用分类对类标进行预测</h5><p><strong>分类</strong>是基于对过往类标已知示例的观察与学习，实现对新样本类标的预测。这些类标是离散的、无序的值，它们可以视为样本的组别信息（group membership）。上文检测垃圾邮件的例子是一个典型的<strong>二类别分类</strong>（binary classification）任务，机器学习算法会生成一系列的规则用以判定邮件是否属于垃圾邮件。</p><p>然而，<strong>类标集合并非一定是二类别分类的</strong>。通过监督学习算法构造的预测模型可以将训练样本库中出现的任何类标赋给一个尚未被标记的新样本。</p><p>比如手写字符识别就是一个典型的<strong>多类别分类</strong>（multi-class classfication）的例子。我们可以将字母表中每个字母的多个不同的手写样本收集起来作为训练数据集。此时，若用户给出一个新的手写字符，我们的预测模型能够以一定的准确率将其判定为字母表中的某个字母。然而，如果我们的训练样本库中没有出现0～9的数字字符，那么模型将无法正确辨别任何输入的数字。</p><p>下图通过一个具有30个训练样本的示例说明二类别分类任务的概念：15个样本被标记为负类别（negative class - 圆圈）；15个被标记为正类别（positive class - 加号）。此时，我们的数据集是二维的，这意味着每个样本都有两个与其关联的值：x1和x2。现在，我们可以通过监督学习算法获得一条规则，并将其表示为一条黑色虚线标识的分界线。可以根据给定的x1、x2值将新样本划分到某个类别中。</p><p><img src="https://ser4wang.oss-cn-beijing.aliyuncs.com/20200530124134.png" alt></p><h5 id="使用回归预测连续输出值"><a href="#使用回归预测连续输出值" class="headerlink" title="使用回归预测连续输出值"></a>使用回归预测连续输出值</h5><p>回归分析（regression analysis）的目的是针对连续型输出变量进行预测。在回归分析中，数据会给出大量的自变量（解释变量）和因变量（输出结果），通过尝试寻找这两种变量之间的关系，就能够预测输出变量。</p><p>例如，如果我们想预测学生的数学考试成绩，如果花费在学习上的时间和最终的考试成绩有关联，则可以将其作为训练数据来训练模型，以根据学习时间预测将来要参加考试的学生的成绩。</p><p>下图用图例阐述了<strong>线性回归</strong>（linear regression）的概念：给定一个自变量x和因变量y，拟合一条直线使得样例数据点与拟合直线之间的距离最短，最常用的就是采用平均平方距离来计算。这样，我们就可以通过对样本数据的训练来获得拟合直线的截距和斜率，从而对新的输入变量值所对应的输出变量值进行预测。</p><p><img src="https://ser4wang.oss-cn-beijing.aliyuncs.com/20200530141632.png" alt></p><h4 id="强化学习-Reinforcement-Learning"><a href="#强化学习-Reinforcement-Learning" class="headerlink" title="强化学习 - Reinforcement Learning"></a>强化学习 - Reinforcement Learning</h4><p>强化学习的目的是构建一个<strong>系统</strong>（Agent），在于<strong>环境</strong>（environment）交互的国策和观念中提高系统的性能。环境的当前状态信息中通常包含一个<strong>反馈</strong>（reward）信号，我们可以将强化学习视为与监督学习相关的一个领域。然而，在强化学习中，这个反馈值不是一个确定的类标或连续的值，而是一个通过反馈函数产生的对当前系统行为的评价。通过与环境的交互，Agent可以通过强化学习来得到一系列行为，通过探索性的试错或者借助精心设计的激励系统使得正向反馈最大化。</p><p>一个最常见的例子就是围棋对弈的游戏（还有Dota的Open AI）。在此，Agent根据棋盘上的当前局势（environment）决定落子的位置，而游戏结束时胜负的判定可以作为激励信号。</p><p><img src="https://ser4wang.oss-cn-beijing.aliyuncs.com/20200530142503.png" alt></p><h4 id="无监督学习-Unsupervised-Learning"><a href="#无监督学习-Unsupervised-Learning" class="headerlink" title="无监督学习 - Unsupervised Learning"></a>无监督学习 - Unsupervised Learning</h4><p>无监督学习的目的是在没有已知输出变量和反馈函数指导的情况下提取有效信息来探索数据的整体结构。</p><h5 id="通过聚类发现数据的子群"><a href="#通过聚类发现数据的子群" class="headerlink" title="通过聚类发现数据的子群"></a>通过聚类发现数据的子群</h5><p><strong>聚类</strong>是一种探索性数据分析技术。在没有任何相关先验信息的情况下，它可以帮助我们将数据划分为有意义的小的组别（簇，cluster）。对数据进行分析时，生成的每个簇中其内部成员之间具有一定的相似度，而与其它簇中的成员则具有较大的不同，这也是为什么聚类有时被称为<strong>无监督分类</strong>。</p><h5 id="数据压缩中的降维"><a href="#数据压缩中的降维" class="headerlink" title="数据压缩中的降维"></a>数据压缩中的降维</h5><p><strong>数据降维</strong>（dimensionality reduction）是无监督学习的另一个子域。通常，我们面对的数据都是高维的（每一次采样都会获取大量的样本值），这就对有限的数据存储空间以及机器学习算法性能提出了挑战。无监督降维是数据特征预处理时常用的技术，用于清除数据中的噪声，它能够在最大程度保留相关信息的情况下将数据压缩到一个维度较小的子空间，但同时也可能会降低某些算法在准确性方面的性能。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>构建机器学习系统的路线：</p><ol><li>数据预处理</li><li>选择预测模型并进行训练</li><li>模型验证与使用未知数据进行预测</li></ol><hr><h2 id="第二章-机器学习分类算法"><a href="#第二章-机器学习分类算法" class="headerlink" title="第二章 机器学习分类算法"></a>第二章 机器学习分类算法</h2><p>本章将介绍最早以算法方式描述的分类机器学习算法：<strong>感知器</strong>（perceptron）和<strong>自适应线性神经元</strong>（adaptive linear neuron）。并实现一个感知器。通过训练使其具备对数据集中数据进行分类的能力。</p><h3 id="罗森布拉特感知器"><a href="#罗森布拉特感知器" class="headerlink" title="罗森布拉特感知器"></a>罗森布拉特感知器</h3><p><strong>罗森布拉特感知器</strong>是由罗森布拉特（Frank Rossenblatt）基于1943年沃伦·麦卡洛可（Warren McCullock）和沃尔特·皮茨（Walter Pitts）提出的麦卡洛可-皮茨神经元（MCP）提出的感知器学习法则。</p><blockquote><p>麦卡洛可和皮茨将神经细胞描述为一个具备二进制输出的逻辑门。树突接受多个输入信号，如果累加的信号超过某一阈值，经细胞体的整合就会生成一个输出信号，并通过轴突进行传递。</p></blockquote><p>罗森布拉特感知器可以自动通过优化得到权重系数，此系数与输入值的乘积决定了神经元是否被激活。在监督学习与分类中，类似算法可用于预测样本所属的类别。</p><p>可以把这个问题看作一个二值分类的任务，我们把两类分别记为1（正类别）和-1（负类别）。我们定义一个<strong>激励函数</strong>（activation function）$$\phi (z)$$</p><p>，它以特定的输入值$x$与相应的权值向量$w$的线性组合作为输入，其中，$z$也被称作净输入（$z=w_1x_1+…+w_mx_m$）:<br>$$<br>w=\left[<br>\begin{matrix}<br>w_1 \\<br>. \\<br>. \\<br>. \\<br>w_m<br>\end{matrix}<br>\right],<br>x=\left[<br>\begin{matrix}<br>x_1\\<br>.\\<br>.\\<br>.\\<br>x_m<br>\end{matrix}<br>\right]<br>$$<br>此时，对于一个特定样本$x(i)$的激励，也就是$\phi(z)$的输出，如果其值大于预设的阈值$\phi$ ，我们将其划分到1类，否则为-1类。在感知器算法中，激励函数是一个简单的分段函数。<br>$$<br>\phi(z)=\{ 1,\ \ \ {if}\ \ \  z &gt; 0 \\<br>\ \{ -1, {其它}<br>$$<br>为了简单起见，我们可以把阈值$\phi$移到等式的左边，并增加一个初始项权重记为$w_0=-\phi$且设$x_0=1$，这样我们就可以把$z$写成一个更加紧凑的形式：<br>$$<br>z=w_0x_0+w_1x_1+…+w_mx_m=w^Tx<br>$$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大一的时候，想到Lab里玩耍，有个博导就跟我聊天，过程中他讲到”么瑟乐宁”，我边听边确认多遍，才知道，噢，是”MachineLearning”。一晃二三年，经过这些年的耳濡目染和博士师兄的安利，对于这个词真是不能再熟悉了。而直到前段时间在工作中看到同事使用HMM对某传统安全产品进行了一次成功的优化时，内心才坚定了”MachineLearning是新英雄时代的阿尔戈”这一想法，于是再也按捺不住心里那股汹涌澎湃的感觉，春宵苦短，所以开始吧。本篇用于记录学习MachineLearning的笔记和想法。（封面应景 — 《Detroit: Become Human》）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ser4wang.oss-cn-beijing.aliyuncs.com/20200530121422.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="MachineLearning" scheme="https://selfsolo.com/categories/MachineLearning/"/>
    
    
      <category term="机器学习" scheme="https://selfsolo.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Python" scheme="https://selfsolo.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>开源DNS服务器源码解析（草稿笔记，待优化）</title>
    <link href="https://selfsolo.com/2019/09/18/%E5%BC%80%E6%BA%90DNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E8%8D%89%E7%A8%BF%E7%AC%94%E8%AE%B0%EF%BC%8C%E5%BE%85%E4%BC%98%E5%8C%96%EF%BC%89/"/>
    <id>https://selfsolo.com/2019/09/18/开源DNS服务器源码解析（草稿笔记，待优化）/</id>
    <published>2019-09-18T12:32:56.000Z</published>
    <updated>2020-05-30T03:25:04.211Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>DNS是网络的基础服务，通过阅读开源的DNS Server源码，可以更好地帮助我们了解其工作机制及原理。本篇的撰写源于一次事故，下面就听在下娓娓道来。</p><a id="more"></a><p>我们选择一个开源的DNS服务器，这里笔者选择的是 <a href="https://github.com/PowerDNS/pdns" target="_blank" rel="noopener">PowerDNS</a>，也是很多组织或企业搭建DNS服务的一个常见选择。</p><h2 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h2><p>暂略</p><p>分支：rec-4.0.x</p><h2 id="递归解析-源码"><a href="#递归解析-源码" class="headerlink" title="递归解析 源码"></a>递归解析 源码</h2><p>分析的几点，</p><ol><li><p>开启Lua与否的区别</p></li><li></li></ol><p>入口看 pdns_recursor.cc 文件，main() 函数主要读取各种配置以及各种初始化。</p><h3 id="startDoResolve-函数"><a href="#startDoResolve-函数" class="headerlink" title="startDoResolve 函数"></a>startDoResolve 函数</h3><h4 id="1-Line-690-760"><a href="#1-Line-690-760" class="headerlink" title="1. Line 690-760"></a>1. Line 690-760</h4><p>![image-20200110211550470](/Users/wangwenqi/Library/Application Support/typora-user-images/image-20200110211550470.png)</p><p>主要初始化一些变量，介绍一部分。</p><p>edns是rfc里用来储存DNS额外信息（客户端IP）。默认不开。</p><p>pw是 DNSPacketWriter，顾名思义，用来写返回包的。</p><p>740 - 746行 设置了一些DNS包的标志位。</p><p>下面初始化了一个SyncRes类（核心），初始化了Lua引擎</p><p>756行 因为DNSSEC的默认值是 process-no-validate，所以默认会进行DNSSEC行为。</p><h4 id="2-Line-779-821"><a href="#2-Line-779-821" class="headerlink" title="2. Line 779-821"></a>2. Line 779-821</h4><p><img src="https://ser4wang.oss-cn-beijing.aliyuncs.com/20200110212045.png" alt></p><p>781行 shouldNotValidate变量设置默认值false</p><h4 id="3-Line-822-973"><a href="#3-Line-822-973" class="headerlink" title="3. Line 822-973"></a>3. Line 822-973</h4><p>到了一个if判断。这是关键位置。</p><p><img src="https://ser4wang.oss-cn-beijing.aliyuncs.com/20200110212817.png" alt></p><p>if的条件是 没开Lua hook 或者 preresolve 这个Lua hook 直接return false，则执行。</p><p>先进行了一次 wantsRPZ (默认true)，根据不同policy进行相应处理。</p><p>下面的try catch会进入一个 beginResolve方法，即进行<strong>递归解析，先不跟进</strong>。</p><p>874行 判断res，是否等于 -2。代码会switch policy的值进行不同操作。</p><p>918行 如果res == RCode::NoError ，遍历结果，按情况会执行一个 nodata hook.</p><p>935行 又执行了一次wantsRPZ</p><h4 id="4-Line-974-1105"><a href="#4-Line-974-1105" class="headerlink" title="4. Line 974-1105"></a>4. Line 974-1105</h4><p><img src="https://ser4wang.oss-cn-beijing.aliyuncs.com/20200112164805.png" alt></p><p>975 判断res值是否等于DROP，是则直接return。</p><p>981 如果错误会打Log</p><p>993 判断res值是否等于 -1，是则返回包设置为Servfail</p><p>若res不等于 -1，写返回的rcode（设置为res值）</p><p>1002 若需要validate（执行lua hook后则不需要，这是一个区分点），则会进行使用validateRecords(ret)验证，根据state值执行不同操作。</p><p>1057 结果不为空，会调用 orderAndShuffle(ret)</p><p>DNSComboWriter类似一个生产者，获取请求的 域名 d_qname 和 请求类型 d_qtype，下面是处理EDNS。</p><p>再看下面</p><p><img src="https://ser4wang.oss-cn-beijing.aliyuncs.com/20191217204919.png" alt></p><p>738行，初始化了一个DNSPacketWriter，用来写返回的packet。</p><p>750行，初始化了解析器。用来做递归解析的。</p><p>752行， 设置了Lua引擎指针 t_pdl，pdns通过Lua的形式提供了各种hook。</p><p>再往下看，784行初始化了res，即返回码，服务端和客户端都会根据这个判断请求状态。如 Rcode为 SERVFAIL 时，很多开源的dns库就会报错。</p><p><img src="https://ser4wang.oss-cn-beijing.aliyuncs.com/20191218103654.png" alt></p><p>813行，会调用lua的一个hook，prerpz()方法。</p><p>往下看</p><p><img src="https://ser4wang.oss-cn-beijing.aliyuncs.com/20191218105837.png" alt></p><p>823行，会调用Lua Hook，preresolve方法，在每次递归解析前会执行这个Hook。</p><p>看if条件，如果没有启用 Lua 或者 preresolve 方法返回了false，会进行默认解析。</p><p>825 - 860 行，看默认解析，是 RPZ 和 policy 的判断，这块暂略。不同policy会直接影响解析结果。</p><p><img src="https://ser4wang.oss-cn-beijing.aliyuncs.com/20191218110645.png" alt></p><p>try的块中，可以看到默认解析会调用 syncres.cc文件中的SyncRes类的beginResolve方法，shouldNotValidate的值是用来判断是否OOB的（OOB暂略）。中间报错会直接返回SERVFAIL。</p><p>暂时不跟进，主要看Lua，往下看</p><p>873行，判断返回码res是否等于-2（-2表示命中了过滤引擎的策略）</p><blockquote><p>syncres.cc</p></blockquote><p><img src="https://ser4wang.oss-cn-beijing.aliyuncs.com/20191218111229.png" alt></p><p>同之前一样，下面就会根据不同policy进行处理。</p><p>往下看，默认解析最后，如果没有报错的话，会执行Lua Hook，nodata方法</p><p><img src="https://ser4wang.oss-cn-beijing.aliyuncs.com/20191218111629.png" alt></p><p>第二个if 执行的是 nxdomain hook。（NXDOMAIN 暂略）</p><p>最后再调用 Lua Hook，postresolve方法。（即解析完后执行）</p><p>往下看，如果返回码res 不等于-1，都会执行</p><p><img src="https://ser4wang.oss-cn-beijing.aliyuncs.com/20191218113239.png" alt></p><p>如果shouldNotValidate为true，即比如postresolve 中返回了false才会执行这段code。</p><p>往下看，</p><p><img src="https://ser4wang.oss-cn-beijing.aliyuncs.com/20191218113958.png" alt></p><p>会调用validateRecords方法（判断CSPF，暂略）判断解析记录的状态。</p><p>然后根据不同状态设置ad码。</p><p>下面是写到返回的packet中。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;DNS是网络的基础服务，通过阅读开源的DNS Server源码，可以更好地帮助我们了解其工作机制及原理。本篇的撰写源于一次事故，下面就听在下娓娓道来。&lt;/p&gt;
    
    </summary>
    
    
      <category term="sourcecode" scheme="https://selfsolo.com/categories/sourcecode/"/>
    
    
      <category term="源码" scheme="https://selfsolo.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="dns" scheme="https://selfsolo.com/tags/dns/"/>
    
  </entry>
  
  <entry>
    <title>黑盒扫描</title>
    <link href="https://selfsolo.com/2019/09/15/%E9%BB%91%E7%9B%92%E6%89%AB%E6%8F%8F/"/>
    <id>https://selfsolo.com/2019/09/15/黑盒扫描/</id>
    <published>2019-09-15T03:02:51.000Z</published>
    <updated>2019-09-16T11:49:57.176Z</updated>
    
    <content type="html"><![CDATA[<p>黑盒扫描应该是很基本的一个安全产品，可以用很低的成本去发现安全问题，同时提升SDL渗透的效率。</p><a id="more"></a><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p>黑盒扫描的目的主要有两个：</p><ol><li>资产发现</li><li>漏洞扫描</li></ol><p>扫描器的效率和表现方面，单机可以用多进程+协程的方式去提qps，资源够也可以使用分布式，如：kafka / celery（后者感觉更重一点，虽然能帮你做很多事情）</p><p>我踩坑设计了一个主要依靠redis做任务的分发和pull执行（主要想糙快猛地实现），现在看来效率的确是因为架构设计有问题导致整体表现不尽如人意。</p><p>自己后来想的一个理想的架构设计：</p><p><img src="https://ser4wang.oss-cn-beijing.aliyuncs.com/Lark20190916-184509.png" alt></p><h2 id="子域名搜集"><a href="#子域名搜集" class="headerlink" title="子域名搜集"></a>子域名搜集</h2><p>子域名搜集是信息搜集里很关键的一步，因为它拓展了很大一部分的攻击面。下面是我对子域名搜集的实践。</p><p>我用python实现了一个子域名搜集工具，主要用到的方法有：</p><ol><li>基于字典</li><li>开源情报 和 搜索引擎</li><li>IP反查</li><li>TLS证书获取</li></ol><p>我使用的前者，部署最方便。</p><p>整体架构：</p><p><img src="https://ser4wang.oss-cn-beijing.aliyuncs.com/Lark20190916-184731.png" alt></p><p>这是单机跑的非理想情况，4核8g，60%cpu，800-1500qps</p><p>几个大小问题：</p><ol><li>域名泛解析</li><li>域名去重</li><li>比较依赖redis</li></ol><p>泛解析有两种解决方式，一种是ip-domain的hash map超过了阈值，最后做清洗；另一种是查完了，就做一次 &lt;随机前缀.目标域名&gt;的查询，判断是否存在，这样（和清洗一个道理）。实际做下来是1方便，因为第二种方式，如果在做判断的同时，有其他做dns query的查到了结果，就会被绕过存入data。</p><p>域名去重是因为首先引入了开源情报和搜索引擎，还有后续得到的CNAME啊，NS啊之类的，不做去重，任务队列可能就大了两三倍。我去重主要依赖redis的set，这样又回引入大key问题，解决大key，可以根据域名的级数（多少个&lt;.&gt;）分去重set，也可以大key分小key，因为并发，暂时没想到好的设计，优化考虑用布隆过滤器去做去重。</p><p>依赖redis，前面有提到，后面就不赘述了。</p><h2 id="敏感文件扫描"><a href="#敏感文件扫描" class="headerlink" title="敏感文件扫描"></a>敏感文件扫描</h2><p>这个我实现的很简单，主要看了github上几个老前辈的实现，总结了一下，可以这样做：</p><ol><li>对目标做一次全站链接爬取（需要考虑url去重）</li><li>根据links生成一级级目录</li><li>配合对应字典，做验证。</li></ol><p>其实有了目录+对应漏洞的字典，主要就是验证了。这块同时可以验证的漏洞有很多，除了敏感文件泄漏，还有目录遍历，未授权访问等等。后者可以通过打分策略来做（实现比较low，也可以用图像识别，ML做）。</p><h2 id="漏洞验证"><a href="#漏洞验证" class="headerlink" title="漏洞验证"></a>漏洞验证</h2><p>可以找一个社区比较大的（poc贡献多），因为一个是自己写poc需要很多时间。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;黑盒扫描应该是很基本的一个安全产品，可以用很低的成本去发现安全问题，同时提升SDL渗透的效率。&lt;/p&gt;
    
    </summary>
    
    
      <category term="security" scheme="https://selfsolo.com/categories/security/"/>
    
    
      <category term="扫描器" scheme="https://selfsolo.com/tags/%E6%89%AB%E6%8F%8F%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>旧Blog不再使用，重新审视自己</title>
    <link href="https://selfsolo.com/2019/09/14/hello-world/"/>
    <id>https://selfsolo.com/2019/09/14/hello-world/</id>
    <published>2019-09-14T12:04:30.577Z</published>
    <updated>2019-09-15T02:24:06.913Z</updated>
    
    <content type="html"><![CDATA[<p>从大一接触安全，懵懵懂懂直到临近毕业，再到字节实习，认识了很多技术大佬，它山之高，让我看到了很多不同的层面和角度，想把这个blog作为道标，重新开始一条严谨对待自己和人生的技术之路。</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从大一接触安全，懵懵懂懂直到临近毕业，再到字节实习，认识了很多技术大佬，它山之高，让我看到了很多不同的层面和角度，想把这个blog作为道标，重新开始一条严谨对待自己和人生的技术之路。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
